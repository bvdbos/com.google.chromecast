'use strict';

const RequestResponseController = require('castv2-client').RequestResponseController;

class MediaController extends RequestResponseController {
	constructor(client, sourceId, destinationId) {
		super(client, sourceId, destinationId, 'urn:x-cast:' + MediaController.APP_URN);
		
		this.homeyChannel = client.createChannel(sourceId, destinationId, 'urn:x-cast:' + MediaController.HOMEY_URN, 'JSON');
		this.lastHomeyRequestId = 0;

		this.currentSession = null; // session;

		const onmessage = (data, broadcast) => {
			// console.log('on message', data, broadcast);
			if (data.type === 'MEDIA_STATUS') {
				const status = data.status[0];
				// Sometimes an empty status array can come through; if so don't emit it
				if (!status) return;
				this.currentSession = status;
				this.emit('status', status);
			}
		};

		const onclose = () => {
			this.removeListener('message', onmessage);
		};

		this.on('message', onmessage);
		this.once('close', onclose);
	}

	getStatus(callback) {
		this.request({ type: 'GET_STATUS' }, (err, response) => {
			if (err) return callback(err);
			const status = response.status[0];
			this.currentSession = status;
			callback(null, status);
		});
	}

	setWallpaperUrl(url, callback) {
		const data = {
			type: 'SET_WALLPAPER_URL',
			url,
		};

		this.homeyRequest(data, callback);
	}

	load(media, options, callback) {
		if (typeof options === 'function' || typeof options === 'undefined') {
			callback = options;
			options = {};
		}

		const data = { type: 'LOAD' };

		data.autoplay = (typeof options.autoplay !== 'undefined')
			? options.autoplay
			: false;

		data.currentTime = (typeof options.currentTime !== 'undefined')
			? options.currentTime
			: 0;

		data.activeTrackIds = (typeof options.activeTrackIds !== 'undefined')
			? options.activeTrackIds
			: [];

		data.repeatMode = (typeof options.repeatMode === "string" &&
		typeof options.repeatMode !== 'undefined')
			? options.repeatMode
			: "REPEAT_OFF";

		data.media = media;

		this.request(data, (err, response) => {
			if (err) return callback(err);
			if (response.type === 'LOAD_FAILED') {
				return callback(new Error('Load failed'));
			}
			if (response.type === 'LOAD_CANCELLED') {
				return callback(new Error('Load cancelled'));
			}
			const status = response.status[0];
			callback(null, status);
		});
	}

	sessionRequest(data, callback) {

		let requestTimeout;

		const sendRequest = () => {
			data.mediaSessionId = this.currentSession.mediaSessionId;
			callback = callback || (() => null);

			this.request(data, (err, response) => {
				if (!callback) return;
				clearTimeout(requestTimeout);
				if (err) return callback(err);
				const status = response.status[0];
				callback(null, status);
			});
		};

		requestTimeout = setTimeout(() => {
			this.removeListener('status', sendRequest);
			callback(new Error('Request timed out'));
			callback = null;
		}, 10000);

		if (!this.currentSession) {
			return this.once('status', sendRequest);
		}
		sendRequest();
	}

	homeyRequest(data, callback) {
		const requestId = ++this.lastHomeyRequestId;

		const onmessage = (response, broadcast) => {
			if (response.requestId === requestId) {
				this.homeyChannel.removeListener('message', onmessage);

				if (response.type === 'INVALID_REQUEST') {
					return callback(new Error('Invalid request: ' + response.reason));
				}

				delete response.requestId;
				callback(null, response);
			}
		}

		this.homeyChannel.on('message', onmessage);

		data.requestId = requestId;

		this.homeyChannel.send(data);
	}

	play(callback) {
		this.sessionRequest({ type: 'PLAY' }, callback);
	}

	pause(callback) {
		this.sessionRequest({ type: 'PAUSE' }, callback);
	}

	stop(callback) {
		this.sessionRequest({ type: 'STOP' }, callback);
	}

	seek(currentTime, callback) {
		const data = {
			type: 'SEEK',
			currentTime: currentTime
		};

		this.sessionRequest(data, callback);
	}

	close() {
		this.stop();
		this.close();
	}
}

module.exports = MediaController;
